{"version":3,"sources":["components/earth/wwwx/shapes/TexturedSurfaceShape.js","components/earth/wwwx/shapes/TexturedSurfacePolygon.js","components/earth/useEww.js","components/earth/Earth.js","components/datemanager/components/datelabel/DateLabel.js","components/datemanager/components/datecontroller/DateController.js","components/datemanager/components/datecontroller/useClock.js","components/datemanager/components/dateselector/DateSelectorScale.js","components/datemanager/components/dateselector/DateSelector.js","components/datemanager/DateManager.js","components/app/App.js","serviceWorker.js","index.js"],"names":["PickedObject","WorldWind","SurfacePolygon","SurfaceShape","useEww","_ref","id","clon","clat","alt","starfield","atmosphere","names","eww","useRef","_useState","useState","_useState2","Object","slicedToArray","setProjection","_useState3","_useState4","_useState5","_useState6","geojsonlayers","setGeojsonlayers","_useState7","_useState8","_useState9","latitude","longitude","altitude","aoi","pickedItems","_useState10","ewwstate","setEwwState","addQuicklookWMS","renderable","console","log","computeSectors","current","drawContext","Sector","FULL_SPHERE","wmsConfigQL","service","layerNames","title","numLevels","format","size","sector","levelZeroDelta","Location","qllayer","WmsLayer","userProperties","date","addLayer","redraw","layers","getLayerByName","name","i","length","displayName","enableRenderables","_x","_enableRenderables","apply","this","arguments","asyncToGenerator","regenerator_default","a","mark","_callee","time","j","renderableStartDate","renderableStopDate","wrap","_context","prev","next","includes","renderables","Date","earthObservation","acquisitionInformation","acquisitionParameter","acquisitionStartTime","getTime","acquisitionStopTime","enabled","timeOffset","stop","setGlobeStates","lo","navigator","lookAtLocation","la","al","range","vp","bl","tr","view","viewport","polygon","pickTerrain","canvasCoordinates","x","y","height","terrainObject","position","Math","round","err","width","getViewPolygon","objectSpread","viewpolygon","handleClick","recognizer","clientX","clientY","pickList","pick","removeLayer","highlighted","objects","userObject","push","handleDoubleClick","point","useEffect","WorldWindow","redrawCallbacks","BasicWorldWindowController","prototype","applyLimits","WWMath","clamp","clickRecognizer","ClickRecognizer","numberOfClicks","doubleClickRecognizer","recognizeSimultaneouslyWith","maxClickInterval","tapRecognizer","TapRecognizer","numberOfTaps","doubleTapRecognizer","maxTapInterval","wmsConfigBg","wmsConfigNames","configuration","baseUrl","slice","starFieldLayer","StarFieldLayer","atmosphereLayer","AtmosphereLayer","quicklookLayer","RenderableLayer","layer","l","setTimeout","goToAnimator","travelTime","goTo","Position","deepPicking","removeGeojson","addGeojson","url","epoch","renderableLayer","properties","updated","ceil","random","GeoJSONParser","load","concat","toConsumableArray","geometry","placemarkAttributes","PlacemarkAttributes","imageScale","imageColor","Color","labelAttributes","offset","Offset","OFFSET_FRACTION","isPointType","isMultiPointType","attributes","isLineStringType","isMultiLineStringType","drawOutline","outlineColor","interiorColor","red","green","blue","outlineWidth","isPolygonType","isMultiPolygonType","ShapeAttributes","highlightAttributes","addWMS","toggleStarfield","toggleAtmosphere","setTime","toggleProjection","prevProj","supportedProjections","newProj","indexOf","globe","projection","ProjectionWgs84","ProjectionEquirectangular","ProjectionMercator","ProjectionPolarEquidistant","toggleNames","Earth","viewdate","_useEww","useHotkeys","react_default","createElement","style","background","left","DateLabel","highlight","animated","className","key","dateFormat","toUpperCase","getUTCFullYear","DateController","startdate","onDateChange","_useClock","autoStart","initdate","duration","setDate","playing","setPlaying","step","refreshrate","ldate","intervalRef","timeoutRef","start","setInterval","clearTimeout","clearInterval","toJSON","togglePause","reset","increaseSpeed","abs","decreaseSpeed","forceDate","newdate","useClock","lastTap","setLasttap","onClick","now","DateSelectorScale","zoomfactor","immediate","scale","timescale","setTimescale","scaleText","_start","_zoom","day","month","hour","monthcode","year","lastday","lastmonth","lastyear","lasthour","tics","putyear","putmonth","putday","putevenhour","puthour","offsetHeight","refdate","getUTCDate","getUTCMonth","getUTCHours","class","pos","label","map","item","top","_useSpring","useSpring","dater","zoomer","_useSpring2","_useSpring2$","set","useLayoutEffect","to","config","onFrame","value","web","div","ref","DateSelector","onFinalDateChange","STEPS_UP","STEPS_DOWN","selector","scaledate","setScaledate","lastStartdate","setlLastStartdate","newstart","setNewstart","active","setActive","setZoomfactor","xy","bind","useGesture","onDrag","_ref2","steparea","zoom","event","first","down","delta","velocity","direction","_ref2$temp","temp","getValue","laststeparea","deltaoffset","Xoffset","parentElement","offsetWidth","pageX","pageY","min","floor","add","sub","decay","onRest","assign","dateselector_DateSelectorScale","points","DateManager","searching","selectorStartdate","setselectorStartdate","controllerStartdate","setcontrollerStartdate","labeldate","setLabelDate","datecontroller_DateController","datelabel_DateLabel","dateselector_DateSelector","App","setViewdate","isFull","setIsfull","_useFullscreen","useFullscreen","window","document","body","isFullscreen","toggleFullscreen","dist_default","onChange","earth_Earth","datemanager_DateManager","Boolean","location","hostname","match","ReactDOM","render","app_App","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.820ecb84.chunk.js","sourcesContent":["import WorldWind from 'webworldwind-esa';\n\nconst PickedObject = WorldWind.PickedObject,\n    SurfacePolygon = WorldWind.SurfacePolygon,\n    SurfaceShape = WorldWind.SurfaceShape;\n\n/**\n * If no image is set, it behaves the same as a SurfaceShape.\n * To set an image pass it to the shape .image property (myShape.image = myImg;)\n *\n * Limitations with an image:\n * The boundaries have to define a quadrilateral (can be defined by 4 corners)\n * If the edges arc over the globe, the interior will not be filled properly\n * Shapes that cross the anti-meridian will not use the image\n * Performance is lower\n *\n * When used with an image it will divide the image in cells (based on the step, maxImageWidth, maxImageHeight values)\n * and draw each image cell to the canvas\n * This is a slow operation, try to keep the number of cells \"low\"\n * For example:\n * step = 1, maxImageWidth = 64, maxImageHeight = 64\n * will produce 4096 (64 * 64 * 1) cells\n */\nclass TexturedSurfaceShape extends SurfaceShape {\n    constructor(attributes) {\n        super(attributes);\n\n        /**\n         * Image to draw on the surface of the shape.\n         * @type {Image}\n         */\n        this.image = null;\n\n        /**\n         * Determines the division step of the image\n         * Lower numbers produce better textures at the expense of performance\n         * @type {Number}\n         */\n        this.step = 1;\n\n        /**\n         * Resizes the image\n         * Higher numbers produce better textures at the expense of performance\n         * @type {Number}\n         */\n        this.maxImageWidth = 64;\n        this.maxImageHeight = 64;\n    }\n\n    get image() {\n        return this._image;\n    }\n\n    set image(img) {\n        this._image = img;\n        this.stateKeyInvalid = true;\n        this._stateId = SurfacePolygon.stateId++;\n    }\n\n    renderToTexture(dc, ctx2D, xScale, yScale, dx, dy) {\n        let attributes = (this.highlighted ? (this.highlightAttributes || this._attributes) : this._attributes);\n        let drawInterior = (!this._isInteriorInhibited && attributes.drawInterior);\n        let drawOutline = (attributes.drawOutline && attributes.outlineWidth > 0);\n        let pickColor;\n\n        if (!drawInterior && !drawOutline) {\n            return;\n        }\n\n        if (dc.pickingMode && !this.pickColor) {\n            this.pickColor = dc.uniquePickColor();\n        }\n\n        if (dc.pickingMode) {\n            pickColor = this.pickColor.toHexString();\n        }\n\n        if (this.crossesAntiMeridian || this.containsPole) {\n            if (drawInterior) {\n                this.draw(this._interiorGeometry, ctx2D, xScale, yScale, dx, dy);\n                ctx2D.fillStyle = dc.pickingMode ? pickColor : attributes.interiorColor.toCssColorString();\n                ctx2D.fill();\n            }\n            if (drawOutline) {\n                this.draw(this._outlineGeometry, ctx2D, xScale, yScale, dx, dy);\n                ctx2D.lineWidth = attributes.outlineWidth;\n                ctx2D.strokeStyle = dc.pickingMode ? pickColor : attributes.outlineColor.toCssColorString();\n                ctx2D.stroke();\n            }\n        } else {\n            if (this.image && !dc.pickingMode) {\n                ctx2D.save();\n            }\n            let points = this._interiorGeometry[0].map(location => ({\n                x: location.longitude * xScale + dx,\n                y: location.latitude * yScale + dy\n            }));\n            this.drawPoints(points, ctx2D);\n            if (drawInterior) {\n                if (this.image && !dc.pickingMode) {\n                    ctx2D.clip();\n                    this.drawImageToPolygon(ctx2D, this.image, points);\n                    ctx2D.restore();\n                }\n                else {\n                    ctx2D.fillStyle = dc.pickingMode ? pickColor : attributes.interiorColor.toCssColorString();\n                    ctx2D.fill();\n                }\n            }\n            if (drawOutline) {\n                ctx2D.lineWidth = attributes.outlineWidth;\n                ctx2D.strokeStyle = dc.pickingMode ? pickColor : attributes.outlineColor.toCssColorString();\n                ctx2D.stroke();\n            }\n        }\n\n        if (dc.pickingMode) {\n            let po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,\n                null, this.layer, false);\n            dc.resolvePick(po);\n        }\n    }\n\n    drawPoints(points, ctx2D) {\n        ctx2D.beginPath();\n        ctx2D.moveTo(points[0].x, points[0].y);\n        for (let i = 1, len = points.length; i < len; i++) {\n            ctx2D.lineTo(points[i].x, points[i].y);\n        }\n    }\n\n    drawImageToPolygon(ctx, image, points) {\n        let canvasWidth = ctx.canvas.width;\n        let canvasHeight = ctx.canvas.height;\n\n        let offScreenCanvas = TexturedSurfaceShape.offScreenCanvas();\n        let offScreenCtx = TexturedSurfaceShape.offScreenCtx();\n\n        let corners = this.getCorners(points);\n        let axesDim = this.getAxesDimensions(corners);\n\n        let offScreenWidth = Math.min(axesDim.distX, this.maxImageWidth);\n        let offScreenHeight = Math.min(axesDim.distY, this.maxImageHeight);\n\n        offScreenCanvas.width = offScreenWidth;\n        offScreenCanvas.height = offScreenHeight;\n        offScreenCtx.drawImage(image, 0, 0, offScreenWidth, offScreenHeight);\n\n        let step = this.step;\n        let width = offScreenWidth - 1;\n        let height = offScreenHeight - 1;\n        let topLeft, topRight, bottomRight, bottomLeft, y1Current, y2Current, y1Next, y2Next;\n\n        for (let y = 0; y < height; y += step) {\n            y1Current = this.lerp(corners[0], corners[3], y / height);\n            y2Current = this.lerp(corners[1], corners[2], y / height);\n            y1Next = this.lerp(corners[0], corners[3], (y + step) / height);\n            y2Next = this.lerp(corners[1], corners[2], (y + step) / height);\n\n            for (let x = 0; x < width; x += step) {\n                topLeft = this.lerp(y1Current, y2Current, x / width);\n                topRight = this.lerp(y1Current, y2Current, (x + step) / width);\n                bottomRight = this.lerp(y1Next, y2Next, (x + step) / width);\n                bottomLeft = this.lerp(y1Next, y2Next, x / width);\n\n                let dWidth = Math.ceil(Math.max(step, Math.abs(topRight.x - topLeft.x), Math.abs(bottomLeft.x - bottomRight.x))) + 1;\n                let dHeight = Math.ceil(Math.max(step, Math.abs(topLeft.y - bottomLeft.y), Math.abs(topRight.y - bottomRight.y))) + 1;\n\n                if (this.isRectInsideCanvas(topLeft, dWidth, dHeight, canvasWidth, canvasHeight)) {\n                    ctx.drawImage(offScreenCanvas, x, y, step, step, topLeft.x, topLeft.y, dWidth, dHeight);\n                }\n            }\n        }\n    }\n\n    getCorners(points, bbox) {\n        bbox = bbox || this.getBbox(points);\n\n        let edgePoints = points.filter(point => this.isEdgePoint(point, bbox));\n\n        if (edgePoints.length === 5 &&\n            this.arePointsEqual(edgePoints[0], edgePoints[edgePoints.length - 1])) {\n            edgePoints.length = 4;\n        }\n\n        if (edgePoints.length > 4) {\n            let leftPoints = edgePoints.filter(point => point.x === bbox.minX);\n            let rightPoints = edgePoints.filter(point => point.x === bbox.maxX);\n\n            let {top: topLeft, bottom: bottomLeft} = this.getTopBottom(leftPoints);\n            let {top: topRight, bottom: bottomRight} = this.getTopBottom(rightPoints);\n\n            return [topLeft, topRight, bottomRight, bottomLeft];\n        }\n\n        let slope1 = this.getSlope(edgePoints[0], edgePoints[2]);\n        let slope2 = this.getSlope(edgePoints[1], edgePoints[3]);\n        let topLeftPoint = this.getTopLeftPoint(slope1, edgePoints[0], edgePoints[2]) ||\n            this.getTopLeftPoint(slope2, edgePoints[1], edgePoints[3]);\n\n        if (!topLeftPoint) {\n            console.log('Could not determine top left corner with the slope method');\n            return edgePoints;\n        }\n\n        let topLeftIndex = edgePoints.findIndex(point => point.x === topLeftPoint.x && point.y === topLeftPoint.y);\n        let newCorners = [];\n        for (let i = topLeftIndex; i < edgePoints.length + topLeftIndex; i++) {\n            newCorners.push(edgePoints[i % edgePoints.length]);\n        }\n\n        return newCorners;\n    }\n\n    getBbox(points) {\n        let bbox = {\n            minX: Number.MAX_SAFE_INTEGER,\n            maxX: Number.MIN_SAFE_INTEGER,\n            minY: Number.MAX_SAFE_INTEGER,\n            maxY: Number.MIN_SAFE_INTEGER,\n        };\n\n        return points.reduce((bbox, point) => {\n            bbox.minX = Math.min(bbox.minX, point.x);\n            bbox.maxX = Math.max(bbox.maxX, point.x);\n            bbox.minY = Math.min(bbox.minY, point.y);\n            bbox.maxY = Math.max(bbox.maxY, point.y);\n\n            return bbox;\n        }, bbox);\n    }\n\n    getTopBottom(points) {\n        return points.reduce((acc, point) => {\n            if (point.y < acc.top.y) {\n                acc.top = point;\n            }\n\n            if (point.y > acc.bottom.y) {\n                acc.bottom = point;\n            }\n\n            return acc;\n        }, {top: points[0], bottom: points[0]});\n    }\n\n    distance(p1, p2) {\n        let dx = p1.x - p2.x;\n        let dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    isEdgePoint(point, bbox) {\n        return (\n            point.x === bbox.minX || point.x === bbox.maxX ||\n            point.y === bbox.minY || point.y === bbox.maxY\n        );\n    }\n\n    arePointsEqual(p1, p2) {\n        return p1.x === p2.x && p1.y === p2.y;\n    }\n\n    getSlope(p1, p2) {\n        return (p1.y - p2.y) / (p1.x - p2.x);\n    }\n\n    getTopLeftPoint(slope, point1, point2) {\n        if (slope <= 0) {\n            return null;\n        }\n\n        if (point1.y < point2.y) {\n            return point1;\n        }\n\n        return point2;\n    }\n\n    getAxesDimensions(corners) {\n        let dx = Math.abs(corners[0].x - corners[1].x);\n        let dy = Math.abs(corners[0].y - corners[1].y);\n\n        let distX = 0;\n        let distY = 0;\n\n        if (dx > dy) {\n            distX = this.distance(corners[0], corners[1]);\n            distY = this.distance(corners[0], corners[3]);\n        }\n        else {\n            distX = this.distance(corners[0], corners[3]);\n            distY = this.distance(corners[0], corners[1]);\n        }\n\n        return {distX, distY};\n    }\n\n    lerp(p1, p2, t) {\n        return {\n            x: p1.x + (p2.x - p1.x) * t,\n            y: p1.y + (p2.y - p1.y) * t\n        };\n    }\n\n    isRectInsideCanvas(point, width, height, canvasWidth, canvasHeight) {\n        return (\n            point.x + width >= 0 &&\n            point.x <= canvasWidth &&\n            point.y + height >= 0 &&\n            point.y < canvasHeight\n        );\n    }\n\n    static offScreenCanvas() {\n        if (!TexturedSurfaceShape.canvas) {\n            TexturedSurfaceShape.canvas = document.createElement('canvas');\n        }\n        return TexturedSurfaceShape.canvas;\n    }\n\n    static offScreenCtx() {\n        if (!TexturedSurfaceShape.ctx) {\n            let canvas = TexturedSurfaceShape.offScreenCanvas();\n            TexturedSurfaceShape.ctx = canvas.getContext('2d');\n        }\n        return TexturedSurfaceShape.ctx;\n    }\n}\n\nexport default TexturedSurfaceShape;","import WorldWind from 'webworldwind-esa';\nimport TexturedSurfaceShape from './TexturedSurfaceShape';\n\nconst SurfacePolygon = WorldWind.SurfacePolygon;\n\n/**\n * @exports TexturedSurfacePolygon\n */\nclass TexturedSurfacePolygon extends TexturedSurfaceShape {\n    /**\n     * Constructs Textured Surface Polygon. The polygon is drawn using the standard attributes. Unlike the standard\n     * surface polygon it draws associated image on the area of the polygon.\n     * @param boundaries {Location[]} Array of locations enclosing the surface polygon.\n     * @param attributes {ShapeAttributes} Attributes used for the styling of the Surface Polygon\n     */\n    constructor(boundaries, attributes) {\n        super(attributes);\n\n        if (!Array.isArray(boundaries)) {\n            throw new Error('TexturedSurfacePolygon - constructor - The specified boundary is not an array.');\n        }\n\n        /**\n         * Boundaries relevant for the current polygon.\n         * @type {Location[]}\n         * @memberof TexturedSurfacePolygon.prototype\n         * @public\n         */\n        this.boundaries = boundaries;\n\n        this._stateId = SurfacePolygon.stateId++;\n    }\n\n    get boundaries() {\n        return this._boundaries;\n    }\n\n    set boundaries(boundaries) {\n        if (!Array.isArray(boundaries)) {\n            throw new Error('TexturedSurfacePolygon - set boundaries - The specified boundary is not an array.');\n        }\n\n        this.resetBoundaries();\n        this._boundaries = boundaries;\n        this._stateId = SurfacePolygon.stateId++;\n        this.stateKeyInvalid = true;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    computeStateKey() {\n        return TexturedSurfacePolygon.staticStateKey(this);\n    }\n\n    /**\n     * @inheritDoc\n     */\n    computeBoundaries(dc) {\n    }\n\n    static staticStateKey(shape) {\n        return SurfacePolygon.staticStateKey(shape) + \" pg \" + shape._stateId;\n    }\n}\n\nexport default TexturedSurfacePolygon;","import React, { useState, useEffect, useRef } from \"react\";\nimport WorldWind from \"webworldwind-esa\";\nimport TexturedSurfacePolygon from './wwwx/shapes/TexturedSurfacePolygon'\n\n\n// BasicWorldWindowController.prototype.applyLimits = function () {\n//     var navigator = this.wwd.navigator;\n\n//     // Clamp latitude to between -90 and +90, and normalize longitude to between -180 and +180.\n//     navigator.lookAtLocation.latitude = WWMath.clamp(navigator.lookAtLocation.latitude, -90, 90);\n//     navigator.lookAtLocation.longitude = Angle.normalizedDegreesLongitude(navigator.lookAtLocation.longitude);\n\n//     // Clamp range to values greater than 1 in order to prevent degenerating to a first-person navigator when\n//     // range is zero.\n//     navigator.range = WWMath.clamp(navigator.range, 1, Number.MAX_VALUE);\n\n//     // Normalize heading to between -180 and +180.\n//     navigator.heading = Angle.normalizedDegrees(navigator.heading);\n\n//     // Clamp tilt to between 0 and +90 to prevent the viewer from going upside down.\n//     navigator.tilt = WWMath.clamp(navigator.tilt, 0, 90);\n\n//     // Normalize heading to between -180 and +180.\n//     navigator.roll = Angle.normalizedDegrees(navigator.roll);\n\n//     // Apply 2D limits when the globe is 2D.\n//     if (this.wwd.globe.is2D() && navigator.enable2DLimits) {\n//         // Clamp range to prevent more than 360 degrees of visible longitude. Assumes a 45 degree horizontal\n//         // field of view.\n//         var maxRange = 2  Math.PI  this.wwd.globe.equatorialRadius;\n//         navigator.range = WWMath.clamp(navigator.range, 1, maxRange);\n\n//         // Force tilt to 0 when in 2D mode to keep the viewer looking straight down.\n//         navigator.tilt = 0;\n//     }\n// };\n\nexport function useEww({ id, clon, clat, alt, starfield, atmosphere, names }) {\n    //console.log('useEww renders')\n    \n  \n    const eww = useRef(null)\n    const [projection, setProjection] = useState(\"3D\")\n    // const [aoi, setAoi] = useState({type: null, value: null})\n    const [aoi, setAoi] = useState('')\n    const [geojsonlayers, setGeojsonlayers] = useState([])\n    const [quicklooklayers, setQuicklooklayers] = useState([])\n    const [ewwstate, setEwwState] = useState({latitude: clat, longitude: clon, altitude: alt, aoi:'', pickedItems: []})\n\n    //toggle atmosphere\n    function toggleAtmosphere() {\n        console.log('toggleAtmosphere')\n        eww.current.layers[3].enabled = !eww.current.layers[3].enabled\n        eww.current.redraw();\n    }\n\n    //toggle starField\n    function toggleStarfield() {\n        console.log('toggleStarfield')\n        eww.current.layers[2].enabled = !eww.current.layers[2].enabled\n        eww.current.redraw();\n    }\n\n    //toggle name overlay\n    function toggleNames() {\n        console.log('toggleNames')\n        eww.current.layers[1].enabled = !eww.current.layers[1].enabled\n        eww.current.redraw();\n    }\n\n    function  getViewPolygon () {\n        let view = eww.current.viewport\n        let area = {}\n        let polygon = ''\n        // console.log('view: ' + view.x + '/' + view.y + '/' + view.width + '/' + view.height);\n\n        let bl ;\n        try { \n            bl =  eww.current.pickTerrain(eww.current.canvasCoordinates(view.x, view.y + view.height)).terrainObject().position\n            bl.latitude = Math.round(bl.latitude * 10000)/10000\n            bl.longitude = Math.round(bl.longitude * 10000)/10000\n        }\n        catch(err) {bl = null;}\n\n\n        let tr ;\n        try { \n            tr = eww.current.pickTerrain(eww.current.canvasCoordinates(view.x + view.width, view.y)).terrainObject().position\n            tr.latitude = Math.round(tr.latitude * 10000)/10000\n            tr.longitude = Math.round(tr.longitude * 10000)/10000\n        }\n        catch(err) {tr = null;}\n\n        //console.log(bl.longitude+'/'+bl.latitude+'/'+tr.longitude+'/'+tr.latitude);\n        if(bl == null || tr == null )  {\n            //   area = {type:\"bbox\", value:\"-180,-90,180,90\"};\n              polygon = ''\n        } else {\n              area = {\n                    type: \"bbox\",\n                    value:\n                           bl.longitude +','\n                          + bl.latitude +','\n                          +tr.longitude +','\n                          +tr.latitude\n              };\n\n              polygon = 'POLYGON((' \n                + bl.longitude + ' ' + bl.latitude + ',' \n                + tr.longitude + ' ' + bl.latitude + ',' \n                + tr.longitude + ' ' + tr.latitude + ',' \n                + bl.longitude + ' ' + tr.latitude + ',' \n                + bl.longitude + ' ' + bl.latitude + '))' \n        }\n        return polygon\n\n    }\n    \n    const addGeojson = (url,epoch) => {\n\n        // console.log('replace: '+replace)\n\n        function shapeConfigurationCallback(geometry, properties) {\n            let configuration = {};\n            configuration.userProperties = properties\n    \n            let placemarkAttributes = new WorldWind.PlacemarkAttributes(null);\n            placemarkAttributes.imageScale = 10;\n            placemarkAttributes.imageColor = new WorldWind.Color(0, 1, 1, 0.2);\n            placemarkAttributes.labelAttributes.offset = new WorldWind.Offset(\n                WorldWind.OFFSET_FRACTION, 5,\n                WorldWind.OFFSET_FRACTION, 5);\n            //placemarkAttributes.imageSource = whiteDot;\n    \n    \n            if (geometry.isPointType() || geometry.isMultiPointType()) {\n                configuration.attributes = new WorldWind.PlacemarkAttributes(placemarkAttributes);\n                \n            } else if (geometry.isLineStringType() || geometry.isMultiLineStringType()) {\n                configuration.attributes.drawOutline = true;\n                configuration.attributes.outlineColor = new WorldWind.Color(\n                    0.1 * configuration.attributes.interiorColor.red,\n                    0.3 * configuration.attributes.interiorColor.green,\n                    0.7 * configuration.attributes.interiorColor.blue,\n                    1\n                );\n                configuration.attributes.outlineWidth = 1;\n            } else if (geometry.isPolygonType() || geometry.isMultiPolygonType()) {\n                configuration.attributes = new WorldWind.ShapeAttributes(null);\n                configuration.attributes.interiorColor = new WorldWind.Color(1, 0, 0, 0.2);\n                configuration.attributes.outlineColor = new WorldWind.Color(1, 0, 0, 0.3);\n\n                configuration.highlightAttributes = new WorldWind.ShapeAttributes(configuration.attributes);\n                configuration.highlightAttributes.outlineColor = new WorldWind.Color(1, 0, 0, 0.4);\n                configuration.highlightAttributes.interiorColor = new WorldWind.Color(1, 0, 0, 0);\n                // configuration.attributes.outlineWidth = 0.3;\n\n                // configuration.attributes.applyLighting = true;\n                // configuration.attributes.imageSource = properties.quicklookUrl\n\n            }\n    \n            //console.log(configuration.attributes);\n            return configuration;\n        }\n\n        \n        function loadCompleteCallback() {\n            console.log(renderableLayer)\n            setGeojsonlayers((geojsonlayers)=>[...geojsonlayers,renderableLayer])\n            enableRenderables(epoch) // uncomment to disable renderables\n            eww.current.redraw();\n        }\n    \n        // if (replace) removeGeojson()\n        let renderableLayer = new WorldWind.RenderableLayer('Products: '+url.properties.updated+Math.ceil(Math.random() * 10000))\n        \n        eww.current.addLayer(renderableLayer);\n        // setGeojsonlayers((geojsonlayers)=>[...geojsonlayers,renderableLayer])\n        // setGeojsonlayers((geojsonlayers)=>[...geojsonlayers,renderableLayer])\n        // setGeojsonlayers(eww.current.layers)\n        let geoJson = new WorldWind.GeoJSONParser(url);\n        geoJson.load(loadCompleteCallback, shapeConfigurationCallback, renderableLayer);\n        // setGeojsonlayers((geojsonlayers)=>[...geojsonlayers,renderableLayer])        \n    }\n\n    function removeGeojson() {\n        for(let i=0;i<geojsonlayers.length;i++) {\n          eww.current.removeLayer(geojsonlayers[i])\n        //   console.log('removing json layers: ')\n        //   console.log(geojsonlayers[i])\n        }\n        setGeojsonlayers((geojsonlayers)=>[])\n        // console.log(geojsonlayers)\n        eww.current.redraw();\n      }\n\n    function addWMS() {\n    }\n\n    function addQuicklookWMS(renderable) {\n\n        console.log(renderable.computeSectors(eww.current.drawContext))\n        console.log(WorldWind.Sector.FULL_SPHERE)\n\n        // for S2:  \n        // https://view.onda-dias.eu/instance00/ows?&service=WMS&request=GetMap&layers=S2L1C_TRUE_COLOR&styles=&format=image/png&transparent=true&version=1.1.1&width=1500&height=1000&srs=EPSG:4326&bbox=12.357903,41.800495,12.625694,41.984760\n\n        \n        // https://view.onda-dias.eu/instance00/ows?&service=WMS&request=GetMap&layers=S1B_IW_GRDH_1SDV_20190520T050758_20190520T050823_016323_01EB81_6EB6&styles=&format=image%2Fpng&transparent=true&version=1.1.1&width=256&height=256&srs=EPSG%3A3857&bbox=2035059.441064533,7044436.526761846,2191602.4749925737,7200979.560689885\n        let wmsConfigQL = {\n            service: \"https://view.onda-dias.eu/instance00/ows\",\n            // layerNames: renderable.userProperties.title,\n            // layerNames: 'S2L1C_TRUE_COLOR',\n            layerNames: 'S1_IW_GRDH_FullResolution',\n            \n            // title: renderable.userProperties.title,\n            title: 'quicklook',\n            numLevels: 19,\n            format: \"image/png\",\n            size: 256,\n            sector: renderable.computeSectors(eww.current.drawContext)[0],\n            // sector: renderable.sector,\n            // sector: WorldWind.Sector.FULL_SPHERE,\n            levelZeroDelta: new WorldWind.Location(90, 90)\n        }\n\n        // let wmsConfigQL = {\n        //     service: \"https://tiles.maps.eox.at/wms\",\n        //     layerNames: \"overlay_bright\",\n        //     title: \"overlay_bright\",\n        //     numLevels: 19,\n        //     format: \"image/png\",\n        //     size: 256,\n        //     sector: WorldWind.Sector.FULL_SPHERE,\n        //     levelZeroDelta: new WorldWind.Location(90, 90)\n        // }\n        // eww.current.removeLayer(getLayerByName('quicklook') )\n        let qllayer =  new WorldWind.WmsLayer(wmsConfigQL, renderable.userProperties.date)\n        eww.current.addLayer(qllayer)\n        eww.current.redraw()\n        console.log(eww.current.layers)\n    }\n\n    function getLayerByName(name) {\n        for (let i = 0; i < eww.current.layers.length; i++) {\n            // console.log('display name: '+eww.current.layers[i].displayName)\n            if (eww.current.layers[i].displayName === name) return eww.current.layers[i]\n        }\n        return null\n    }\n\n    async function enableRenderables(time) {\n        let timeOffset = 1000 * 60 * 60 * 3 // 3 hours\n        for (let i = 0; i < eww.current.layers.length; i++) {\n            if (eww.current.layers[i].displayName.includes('Products:')) {\n                \n                for (let j = 0; j < eww.current.layers[i].renderables.length; j++) {\n                    let renderable = eww.current.layers[i].renderables[j]\n                    if (time != 0) {\n                        let renderableStartDate = (new Date(renderable.userProperties.earthObservation.acquisitionInformation[0].acquisitionParameter.acquisitionStartTime)).getTime()\n                        let renderableStopDate = (new Date(renderable.userProperties.earthObservation.acquisitionInformation[0].acquisitionParameter.acquisitionStopTime)).getTime()\n                        renderable.enabled = (renderableStartDate <= time+timeOffset/2 && renderableStopDate >= time-timeOffset/2) ? true : false   \n                    } else {\n                        renderable.enabled = false\n                    }         \n                }\n            }\n            if (eww.current.layers[i].displayName === 'quicklook') {\n                // eww.current.layers[i].enabled = \n            }\n        }\n\n    }\n\n    function addQuicklook(renderable) {\n\n        function imageLoader(url, useCredentials) {\n            return new Promise((resolve, reject) => {\n                const img = new Image();\n        \n                img.onload = function() {\n                    resolve(img);\n                };\n        \n                img.onerror = function(e){\n                    reject(e);\n                };\n        \n                img.crossOrigin = useCredentials ? 'Use-Credentials' : 'Anonymous';\n                img.src = url;\n                console.log(' adding QL')\n            });\n        }\n\n\n        // console.log(' adding QL')\n        //  console.log(renderable.attributes)\n        // let quicklook =  new TexturedSurfacePolygon(renderable.sector)\n        // let quicklookLayer = new WorldWind.RenderableLayer('Quicklooks')\n        // // quicklookLayer.addRenderable(quicklook)\n        // // setQuicklooklayers((quicklooklayers)=>[...quicklooklayers,quicklookLayer])\n        // // eww.current.addLayer(quicklookLayer)\n        // let ql = new Image()\n        // ql.src = renderable.userProperties.quicklookUrl\n        // quicklook.image = ql\n        \n        imageLoader(renderable.userProperties.quicklookUrl,true).then(image => {\n            let quicklookLayer = getLayerByName('Quicklooks')\n            removeQuicklooks()\n            let footprint = [\n                renderable.boundaries[0][0],\n                renderable.boundaries[0][3],\n                renderable.boundaries[0][2],\n                renderable.boundaries[0][1]\n            ]\n            // footprint[0].pop()\n            console.log(footprint)\n            let quicklook =  new TexturedSurfacePolygon(footprint,renderable.attributes)\n            quicklook.maxImageWidth = 64\n            quicklook.maxImageHeight = 64\n            \n            quicklook.image = image\n            quicklookLayer.addRenderable(quicklook)\n            eww.current.addLayer(quicklookLayer)\n            eww.current.redraw()\n        })\n    }\n\n    function removeQuicklooks() {\n        getLayerByName('Quicklooks').removeAllRenderables()\n        eww.current.redraw()\n    }\n\n    function setTime(epoch) {\n        getLayerByName('StarField').time = getLayerByName('Atmosphere').time = new Date(epoch)\n        enableRenderables(epoch)\n        // console.log('display name: ')\n        // console.log(getLayerByName('StarField').displayName)\n        eww.current.redraw();\n        \n\n     }\n\n\n    function toggleProjection() {\n        setProjection( prevProj => {\n          console.log(\"prevProjection: \"+prevProj)\n          let supportedProjections = [ \"3D\", \"Equirectangular\", \"Mercator\"];\n          let newProj = (supportedProjections.indexOf(prevProj) + 1)%supportedProjections.length\n          console.log(\"newProjection: \"+supportedProjections[newProj])\n          switch (supportedProjections[newProj]) {\n            case \"3D\":\n                eww.current.globe.projection = new WorldWind.ProjectionWgs84();\n                break;\n            case \"Equirectangular\":\n                eww.current.globe.projection = new WorldWind.ProjectionEquirectangular();\n                break;\n            case \"Mercator\":\n                eww.current.globe.projection = new WorldWind.ProjectionMercator();\n                break;\n            case \"North Polar\":\n                eww.current.globe.projection = new WorldWind.ProjectionPolarEquidistant(\"North\");\n                break;\n            case \"South Polar\":\n                eww.current.globe.projection = new WorldWind.ProjectionPolarEquidistant(\"South\");\n                break;\n            default:\n            eww.current.globe.projection = new WorldWind.ProjectionWgs84();\n            }\n          eww.current.redraw();\n          return supportedProjections[newProj]\n          })      \n      }\n\n    // callback from eww   \n    const setGlobeStates = () => {\n        \n        let lo = eww.current.navigator.lookAtLocation.longitude\n        let la = eww.current.navigator.lookAtLocation.latitude\n        let al = eww.current.navigator.range\n        let vp = (al < 2000000?getViewPolygon():'')\n\n        setEwwState((ewwstate) => { return {...ewwstate, longitude:lo, latitude: la, altitude: al, viewpolygon: vp}}) \n\n    }\n\n    // handler for tap/click\n\n    const handleClick  = (recognizer) => {\n        // console.log('click')\n        let x = recognizer.clientX\n        let y = recognizer.clientY\n        // Perform the pick. Must first convert from window coordinates to canvas coordinates, which are\n        // relative to the upper left corner of the canvas rather than the upper left corner of the page.\n        let pickList = eww.current.pick(eww.current.canvasCoordinates(x, y));\n        console.log(pickList)\n        if (pickList.terrainObject()) {\n            // position = pickList.terrainObject().position;\n            // store list of selected footprints in a string for later comparison\n            eww.current.removeLayer(getLayerByName('quicklook') )\n            // de-highlight all rendereables\n            for (let i = 0; i < eww.current.layers.length; i++) {\n                if (eww.current.layers[i].displayName.includes('Products:')) {                    \n                    for (let j = 0; j < eww.current.layers[i].renderables.length; j++) {\n                        let renderable = eww.current.layers[i].renderables[j]\n                        renderable.highlighted = false\n                    }\n                }\n            }\n    \n            // ... and now highlight all picked rendereables\n            let pickedItems = []\n            for (let i = 0; i < pickList.objects.length; i++) {\n                if (pickList.objects[i].userObject instanceof WorldWind.SurfaceShape) {\n                    pickedItems.push(pickList.objects[i].userObject) \n                    pickList.objects[i].userObject.highlighted = !pickList.objects[i].userObject.highlighted\n                    \n                    addQuicklookWMS(pickList.objects[i].userObject)\n                }\n            }\n            console.log(pickedItems)\n            setEwwState((ewwstate) => { return {...ewwstate, pickedItems: pickedItems}})\n            eww.current.redraw()\n        } else {\n            console.log('No position !');\n            return;\n        }\n\n\n    }\n\n    const handleDoubleClick  = (recognizer) => {\n        console.log('double click')\n        let x = recognizer.clientX\n        let y = recognizer.clientY\n        let pickList = eww.current.pick(eww.current.canvasCoordinates(x, y));\n\n        let position;\n  \n  \n        // Get coordinates of clicked point and list of selected footprints. Do nothing if click done outside the globe.\n        if (pickList.terrainObject()) {\n            position = pickList.terrainObject().position;\n            // eww.current.goTo(new WorldWind.Location(position.latitude, position.longitude));\n\n            let point = \"POINT(\"+position.longitude+' '+position.latitude+\")\"\n            \n            setEwwState((ewwstate) => { return {...ewwstate, aoi: point}}) \n    \n        } else {\n              console.log('No position !');\n              setEwwState((ewwstate) => { return {...ewwstate, aoi: ''}})\n        }\n  \n        \n\n       \n    }\n\n    // useEffect(() => {\n    //     console.log(\"useEffect aoi: \" + aoi)\n    //     let newewwstate = {...ewwstate, aoi: aoi}\n    //     setEwwState(newewwstate)\n    // }, [aoi]); \n\n    // didMount effect\n    useEffect(() => {\n        console.log(\"useEffect (mount) in Eww  star/atmo: \"+ starfield+'/'+atmosphere)\n        // eww.current = new WorldWind.WorldWindow(id, elevationModel);\n        eww.current = new WorldWind.WorldWindow(id);\n        eww.current.redrawCallbacks.push(setGlobeStates)\n\n        // Define a min/max altitude limit\n        WorldWind.BasicWorldWindowController.prototype.applyLimits = function () {\n            eww.current.navigator.range = WorldWind.WWMath.clamp(eww.current.navigator.range, 2000, 300000000);\n        }\n\n        // define click/tap recognisers\n        // let tapRecognizer = new WorldWind.TapRecognizer(eww.current, handleClick);\n        // tapRecognizer.numberOfTaps = 1;\n        // let doubleTapRecognizer = new WorldWind.TapRecognizer(eww.current, handleDoubleClick);\n        // doubleTapRecognizer.numberOfTaps = 2;\n        // doubleTapRecognizer.recognizeSimultaneouslyWith(tapRecognizer);\n\n        let clickRecognizer = new WorldWind.ClickRecognizer(eww.current, handleClick);\n        clickRecognizer.numberOfClicks = 1;\n        let doubleClickRecognizer = new WorldWind.ClickRecognizer(eww.current, handleDoubleClick);\n        doubleClickRecognizer.numberOfClicks = 2;\n        doubleClickRecognizer.recognizeSimultaneouslyWith(clickRecognizer);\n        doubleClickRecognizer.maxClickInterval = 200;\n\n        let tapRecognizer = new WorldWind.TapRecognizer(eww.current, handleClick);\n        tapRecognizer.numberOfTaps = 1;\n        let doubleTapRecognizer = new WorldWind.TapRecognizer(eww.current, handleDoubleClick);\n        doubleTapRecognizer.numberOfTaps = 2;\n        doubleTapRecognizer.recognizeSimultaneouslyWith(tapRecognizer);\n        doubleTapRecognizer.maxTapInterval = 200;\n\n\n\n        //setWwd(eww);\n        let wmsConfigBg = {\n            service: \"https://tiles.esa.maps.eox.at/wms\",\n            layerNames: \"s2cloudless-2018\",\n            title: \"s2cloudless-2018\",\n            numLevels: 19,\n            format: \"image/png\",\n            size: 256,\n            sector: WorldWind.Sector.FULL_SPHERE,\n            levelZeroDelta: new WorldWind.Location(90, 90)\n        }\n    \n        let wmsConfigNames = {\n            service: \"https://tiles.maps.eox.at/wms\",\n            layerNames: \"overlay_bright\",\n            title: \"overlay_bright\",\n            numLevels: 19,\n            format: \"image/png\",\n            size: 256,\n            sector: WorldWind.Sector.FULL_SPHERE,\n            levelZeroDelta: new WorldWind.Location(90, 90)\n        }\n        WorldWind.configuration.baseUrl = WorldWind.configuration.baseUrl.slice(0,-3)\n        let starFieldLayer = new WorldWind.StarFieldLayer();\n        let atmosphereLayer = new WorldWind.AtmosphereLayer('images/BlackMarble_2016_01deg.jpg');\n        // let atmosphereLayer = new WorldWind.AtmosphereLayer('images/BlackMarble_2016_3km.jpg');\n        \n        //atmosphereLayer.minActiveAltitude = 5000000\n\n        let quicklookLayer = new WorldWind.RenderableLayer('Quicklooks')\n    \n        let layers = [\n            { layer: new WorldWind.WmsLayer(wmsConfigBg, \"\"), enabled: true },\n            { layer: new WorldWind.WmsLayer(wmsConfigNames, \"\"), enabled: names },\n            { layer: starFieldLayer, enabled: starfield },\n            { layer: atmosphereLayer, enabled: atmosphere },\n            { layer: quicklookLayer, enabled: true }\n        ];\n    \n        for (let l = 0; l < layers.length; l++) {\n            layers[l].layer.enabled = layers[l].enabled;\n            eww.current.addLayer(layers[l].layer);\n        }\n        //let date = new Date();\n        starFieldLayer.time = new Date();\n        atmosphereLayer.time = new Date();\n        setTimeout(() => {\n            eww.current.goToAnimator.travelTime = 1000;\n            eww.current.goTo(new WorldWind.Position(clat, clon, alt));\n            eww.current.redraw();\n            }, 2000)\n    \n        eww.current.redraw();\n        eww.current.deepPicking = true;\n        // eww.current.orderedRenderingFilters.push(declutterByTime)\n    }, []); // effect runs only once\n        \n  \n  return { ewwstate, removeGeojson, addGeojson, addWMS, toggleStarfield, toggleAtmosphere, setTime, toggleProjection, toggleNames };\n}\n","import React, {useState, useEffect, useLayoutEffect, useRef} from 'react'\nimport './Earth.css'\nimport { useEww } from \"./useEww\"\nimport { useHotkeys } from 'react-hotkeys-hook'\n\n\n\n\n\n\nfunction Earth({ viewdate, id, clat, clon, alt, starfield, atmosphere, names }) {\n\n    const {\n        ewwstate,\n        addGeojson,\n        removeGeojson,\n        addWMS,\n        toggleProjection,\n        toggleAtmosphere,\n        toggleStarfield,\n        toggleNames,\n        setTime\n    } = useEww({\n        id: id,\n        clat: clat,\n        clon: clon,\n        alt: alt,\n        starfield: starfield,\n        atmosphere: atmosphere,\n        names: names\n    })\n\n    useHotkeys(\"p\",toggleProjection)  \n    useHotkeys(\"a\",toggleAtmosphere)  \n    useHotkeys(\"s\",toggleStarfield)  \n    useHotkeys(\"n\",toggleNames)  \n    useHotkeys(\"c\",removeGeojson)\n\n    useEffect(() => {\n        setTime(viewdate.getTime())\n    },[viewdate])\n\n\n\n    let globeStyle = {\n        background: 'inherit',\n        position: \"fixed\",\n        left: 0,\n        width: '100%',\n        height: '100%'\n    };\n        \n    return (\n            <canvas id={id} style={globeStyle} />\n    );\n}\n\nexport default Earth\n","import React from 'react';\nimport dateFormat from \"dateformat\"\nimport './DateLabel.css';\n\nfunction DateLabel({date, highlight, animated}) {\n\n\n    return (\n        <div className='LabelContainer' >\n            <div className='Date'>\n                <div className={highlight==='day' || highlight==='none'?'DayLabel':'DayLabel Greyedout'}  key='day'  >{dateFormat(date,'UTC:dd')}</div>\n                <div className='YearMonth'>\n                    <div className={highlight==='month' || highlight==='none'?'MonthLabel ':'MonthLabel  Greyedout'}  key='month' >{dateFormat(date,'UTC:mmm').toUpperCase()}</div>\n                    <div className={highlight==='year' || highlight==='none'?'YearLabel ':'YearLabel Greyedout'}  key='year' >{date.getUTCFullYear()}</div>\n                </div>\n            </div>\n            <div className={animated?'Line  Line-active':'Line'} key='line' ></div>\n            <div className={highlight==='time' || highlight==='none'?'TimeLabel ':'TimeLabel Greyedout'} key='time' >{dateFormat(date,'UTC:HH:MM:ss')}</div>\n        </div>\n    )\n}\nexport default DateLabel\n","import React, {useEffect, useState} from 'react';\nimport { useClock } from \"./useClock\"\nimport { useHotkeys } from 'react-hotkeys-hook'\n\n\nimport './DateController.css';\n\nfunction DateController({startdate, onDateChange}) {\n\n    const {\n        date,\n        // playing,\n        togglePause,\n        reset,\n        increaseSpeed,\n        decreaseSpeed,\n        // forceDate\n    } = useClock({\n        autoStart: false,\n        duration: 600000,\n        initdate: startdate\n    })\n\n\n\n    useHotkeys(\"t\",togglePause)\n    useHotkeys(\"r\",()=>{reset() })\n    useHotkeys(\".\",increaseSpeed)\n    useHotkeys(\",\",decreaseSpeed)\n\n    \n\n\n    useEffect(() => {\n        // console.log(\"date from useClock: \"+new Date(date).toJSON())\n        onDateChange(date)\n        //forceDate(date)\n        //setAppdate({appdate: new Date(date)})\n    },[date]);\n\n    useEffect(() => {\n        // console.log(\"date from datemanager: \"+new Date(date).toJSON())\n        // forceDate(startdate)\n        //forceDate(date)\n        //setAppdate({appdate: new Date(date)})\n    },[startdate]);\n\n    const [lastTap, setLasttap] = useState()\n    const handleDoubleTap = () => {\n        const now = Date.now();\n        if (lastTap && (now - lastTap) < 300) {\n          reset();\n        } else {\n            setLasttap(now)\n            togglePause()\n        }\n      }\n\n\n    return (\n        <div className='DateController' onClick={handleDoubleTap}/>\n    )\n}\nexport default DateController\n","import { useState, useEffect, useRef } from \"react\";\n\n\nexport function useClock({ autoStart, duration, initdate }) {\n    //console.log('useClock renders')\n    //const { autoStart, duration } = settings || {};\n  \n    // let initDate = startdate\n    const [date, setDate] = useState(initdate)\n    const [playing, setPlaying] = useState(false)\n    // const [stepstate, setStepstate] = useState(1000*60*60)\n    // const [refreshrate, setrefreshrate] = useState(200)\n    \n    const step = useRef() \n    const refreshrate = useRef() \n    // step.current = 1000*60*60\n    refreshrate.current = 50\n    \n    const ldate = useRef()\n\n      // Control functions\n    const intervalRef = useRef()\n    const timeoutRef = useRef()\n    \n\n    // function increaseSpeed() {\n    //     setStep ( () => {\n    //         let newstate = (step > 0)? step * 2:step / 2\n    //         if(Math.abs(newstate) < refreshrate) newstate = refreshrate\n    //         return newstate\n    //     })\n    // }\n    // function decreaseSpeed() {\n    //     setStep (() => {\n    //         let newstate = (step > 0)? step / 2:step * 2\n    //         if(Math.abs(newstate) < refreshrate) newstate = refreshrate\n    //         return newstate\n    //     })\n    // }\n    function increaseSpeed() {\n        // stop()\n        step.current = (step.current > 0)? step.current *= 2:step.current /= 2\n        if(Math.abs(step.current) < refreshrate.current) step.current = refreshrate.current\n        console.log('step: '+step.current)\n        // setStepstate((st)=>st*2)\n        // start()\n    }\n    function decreaseSpeed() {\n        step.current = (step.current > 0)? step.current /= 2:step.current *= 2\n        if(Math.abs(step.current) < refreshrate.current) step.current = -1 * refreshrate.current\n        // setStepstate((st)=>st/2)\n    }\n\n    function togglePause() {\n        if (playing) {\n            stop()\n        } else {\n            start()\n        }\n    }\n    \n    function start() {\n        console.log('start clock')\n        if(!step.current) step.current = 1000*60*60\n        intervalRef.current = setInterval( ()=>{\n            ldate.current += step.current\n            setDate(new Date(ldate.current))\n        },refreshrate.current)\n        \n        setPlaying(true)\n    }\n    \n    function stop() {\n        console.log('stop clock')\n        if(timeoutRef.current) clearTimeout(timeoutRef.current)\n        if (intervalRef.current) clearInterval(intervalRef.current)\n        setPlaying(false)\n    }\n    \n\n    function reset() {\n        stop()\n        ldate.current = new Date().getTime()\n        setDate(new Date(ldate.current))\n\n    }\n\n     \n    function forceDate(newdate) {\n        console.log('forcedate useclock: '+newdate.toJSON())\n        if(playing) {\n            stop()\n            ldate.current = newdate.getTime()\n            start()    \n        } else {\n            ldate.current = newdate.getTime()\n        }\n    }\n\n    useEffect(() => {\n        console.log('init start useclock '+initdate.toJSON())\n        // if ( !playing )  ldate.current = initdate.getTime()\n        if ( playing ) {\n                stop()\n            ldate.current = initdate.getTime()\n            start()\n        } else {\n            ldate.current = initdate.getTime()\n        }  \n    }, [initdate])\n\n\n\n    // didMount effect\n    useEffect(() => {\n        console.log('render useclock')\n        // setDate((new Date()).getTime())\n        ldate.current = new Date().getTime()\n        if (autoStart) {\n            start();\n        }\n        //return reset;\n    }, []);\n\n  \n  return { date, playing, togglePause, reset, increaseSpeed, decreaseSpeed, forceDate };\n}\n","import React, {useState, useEffect,useLayoutEffect, useRef} from 'react';\nimport {useSpring, animated} from 'react-spring'\nimport './DateSelector.css';\n\nfunction DateSelectorScale({date, zoomfactor, immediate}) {\n\n    const scale = useRef()\n    const [start, setStart] = useState(date)    \n    const [active, setActive] = useState(false)    \n    const [timescale, setTimescale] = useState('')    \n    // const [zoom, setZoom] = useState(zoomfactor)    \n\n\n    useEffect(() => {  \n        return () => {}          \n    })\n        \n    const scaleText = (_start, _zoom) => {\n        // console.log('_start: '+_start.toJSON()+'  zoom: '+_zoom)\n        if(!scale.current) return\n            \n        const monthcode = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC']\n        const isEven = num => ((num % 2) == 0) ? true : false;\n\n\n        let day, month, hour, year = 0\n        let lastday =0\n        let lastmonth = 0\n        let lastyear = 0\n        let lasthour = 0\n        let tics = []    \n        let putyear = (_zoom < 1000*60*60*24*30*10)\n        let putmonth = (_zoom < 1000*60*60*24*5)\n        let putday = (_zoom < 1000*60*60*2)\n        let putevenhour = (_zoom < 1000*60*20)\n        let puthour = (_zoom < 1000*60*8)\n        // console.log('  zoom: '+((_zoom*10)/(1000*60*60*24) ) +'  puthour: '+puthour+'  putday: '+putday+'  putmonth: '+putmonth+'  putevenhour: '+putevenhour)\n        let lastpos = 0\n        for ( let i=0 ; i < scale.current.offsetHeight ; i+=1 ) {\n            let refdate = new Date( (i- scale.current.offsetHeight/2) * _zoom + _start.getTime()  )\n            day = refdate.getUTCDate()\n            month = monthcode[refdate.getUTCMonth()]\n            hour = refdate.getUTCHours()\n            year = refdate.getUTCFullYear()\n\n            if (putevenhour) {\n                if(hour != lasthour) {\n                    if (hour != 0 &&  (isEven(hour) || puthour)) {\n                        tics.push({class:'HourTic', pos: i, label: hour})\n                    } else  {\n                        if (hour == 0) {\n                            tics.push({class:'DayTic', pos: i, label: day})\n                            tics.push({class:'MonthTic', pos: i, label: month})\n                            tics.push({class:'YearTic', pos: i, label: year})            \n                        }\n                    }\n                }\n    \n            } else if (putday) {\n                if(day !== lastday) {\n                    if (day != 1) {\n                        tics.push({class:'DayTic', pos: i, label: day})\n                    } else {\n                        tics.push({class:'DayTic', pos: i, label: day})\n                        tics.push({class:'MonthTic', pos: i, label: month})\n                        tics.push({class:'YearTic', pos: i, label: year})\n                     }\n                    \n                }\n    \n            } else if (putmonth) {\n                if(month !== lastmonth && lastday!=0 && putmonth) {\n                    if (month !== 'JAN') {\n                        tics.push({class:'MonthTic', pos: i, label: month})\n                    } else {\n                        tics.push({class:'MonthTic', pos: i, label: month})\n                        tics.push({class:'YearTic', pos: i, label: year})\n                    }\n                }\n    \n            } else if (putyear) {\n                if(year !== lastyear && lastmonth !== 0 ) {\n                    if (month !== 'JAN') {\n                        tics.push({class:'MonthTic', pos: i, label: month})\n                    } else {\n                        // tics.push({class:'MonthTic', pos: i, label: month})\n                        tics.push({class:'YearTic', pos: i, label: year})\n                    }\n                }\n    \n            }\n\n            lastday = day\n            lastyear = year\n            lastmonth = month\n            lasthour = hour\n        }\n        \n        return tics.map(item => (            <div className={item.class} key={item.class+item.pos} style={{top:item.pos}}>{item.label}</div>))\n    }\n\n    // useLayoutEffect(() => {\n    //     setTimescale(scaleText(date,zoomfactor))\n    // },[date,zoomfactor])\n\n\n    const [{ dater, zoomer }, set] = useSpring(() => ({ dater: date.getTime(), zoomer: zoomfactor}))\n    useLayoutEffect(() => {\n        // console.log('zoomfactor: '+zoomfactor+'  to: '+date.toJSON())\n        \n        set({ \n            to: {\n                zoomer: zoomfactor, \n                dater: date.getTime()\n            },\n            config: {  duration: 400},\n            immediate: false,\n            onFrame: ()=>{\n                // console.log(zoomer.value+'/ '+(new Date(dater.value)).toJSON())\n                // setTimescale(scaleText(new Date(dater.value),zoomer.value))\n                setTimescale(scaleText(new Date(dater.value),zoomer.value))\n            }\n        })\n\n    },[ zoomfactor])\n\n    useLayoutEffect(() => {\n        // console.log('zoomfactor: '+zoomfactor+'  to: '+date.toJSON())\n        \n        set({ \n            to: {\n                zoomer: zoomfactor, \n                dater: date.getTime()\n            },\n            config: {  duration: 400},\n            immediate: immediate,\n            onFrame: ()=>{\n                // console.log(zoomer.value+'/ '+(new Date(dater.value)).toJSON())\n                // setTimescale(scaleText(new Date(dater.value),zoomer.value))\n                setTimescale(scaleText(new Date(dater.value),zoomer.value))\n            }\n        })\n\n    },[date])\n\n\n    return (\n        <animated.div ref={scale} className='DateSelectorScale' >\n            {timescale}\n        </animated.div>\n    )\n}\nexport default DateSelectorScale\n","import React, {useState, useEffect, useLayoutEffect, useRef} from 'react'\nimport {useSpring, animated, config} from 'react-spring'\nimport { useGesture } from 'react-use-gesture'\nimport { add, sub, scale } from 'vec-la'\nimport DateSelectorScale from './DateSelectorScale'\nimport useDebounce from '../../utils/useDebounce'\n\nimport './DateSelector.css';\n// import { start } from 'repl';\n\nfunction DateSelector({startdate, onDateChange, onFinalDateChange}) {\n    const STEPS_UP = [ 1000*60*60 ,  1000*60*60*24, 1000*60*60*24*15]\n    const STEPS_DOWN = [ 1000*60*60 , 1000*60*10, 1000*60*1.8, 1000*27, 1000*60*60*24]\n    \n\n    const selector = useRef()\n    const offset = useRef()\n    if(!offset.current) offset.current = [0, 0 ]\n    \n    const [scaledate, setScaledate ] = useState(startdate)\n    // const debouncedScaledate = useDebounce(scaledate, 10);\n\n    const [lastStartdate, setlLastStartdate ] = useState(startdate)\n    \n    const [newstart, setNewstart ] = useState(startdate)\n    const [active, setActive ] = useState(false)\n\n    // zoomfactor: how long is a pixel in ms\n    const [zoomfactor, setZoomfactor ] = useState(STEPS_UP[0])\n\n    const [{ xy }, set] = useSpring(() => ({ xy: [0,0] }))\n\n    const bind = useGesture({\n\n        onDrag: ({  event, first, down, delta, velocity, direction, temp = {\n            xy: xy.getValue(),\n            laststeparea: 0,\n            deltaoffset: [0,0]\n            }\n        }) => {\n            let Xoffset = selector.current.parentElement.offsetWidth - (event.pageX?event.pageX:selector.current.parentElement.offsetWidth)\n            let Yoffset = (event.pageY?event.pageY:selector.current.parentElement.offsetHeight) - selector.current.offsetHeight/2\n\n            let steparea\n            let zoom\n\n            if(Yoffset > 0) {\n                steparea = Math.min(STEPS_UP.length-1,Math.floor((Xoffset-selector.current.offsetWidth)/60+1))\n                steparea = (steparea > STEPS_UP.length-1)?STEPS_UP.length:steparea\n                steparea = (steparea < 0)?0:steparea\n                zoom = STEPS_UP[steparea]\n            } else {\n                steparea = Math.min(STEPS_DOWN.length-1,Math.floor((Xoffset-selector.current.offsetWidth)/60+1))\n                steparea = (steparea > STEPS_DOWN.length-1)?STEPS_DOWN.length:steparea\n                steparea = (steparea < 0)?0:steparea\n                zoom = STEPS_DOWN[steparea]\n            }\n\n            // console.log(steparea)\n            let step = 1\n            // console.log(offset.current)\n            // if (Xoffset > selector.current.offsetWidth) steparea = 1\n            // if (Xoffset > selector.current.offsetWidth + 100) steparea = 2\n            \n            // for ( let i = 0 ; i < STEPS.length ; i++ ) {\n\n            // }\n            \n            if (steparea !== temp.laststeparea) {\n                console.log(' step changed: '+temp.laststeparea+' to '+steparea)\n                \n                setZoomfactor(zoom)\n                setNewstart(scaledate)\n                temp.laststeparea = steparea\n                temp.xy = [0,0]\n                temp.deltaoffset = delta\n                \n            } \n\n            if (first) setActive(true)\n\n            velocity = (Math.abs(velocity)<.2)?0:velocity  \n            // console.log('velocity '+velocity) \n            \n            set({ \n                // xy: add(scale(sub(delta,temp.deltaoffset),step), temp.xy), \n                xy: add(scale(add(sub(delta,temp.deltaoffset),offset.current),step), temp.xy), \n                immediate: down, \n                config: { velocity: scale(direction, velocity*step), decay: true},\n                // config: { mass: 10, tension: 20 , friction: 40, precision: 1 },\n                // onFrame: ()=>{console.log('xy: '+xy.getValue())},\n                // config: config.gentle,\n                // config: {},\n                onFrame: ()=>{\n                    let newdate = new Date(newstart.getTime() - xy.getValue()[1] * zoomfactor)\n                    // onDateChange(newdate)\n                    setScaledate(newdate)\n                    setlLastStartdate(newdate)\n                },\n                // onFrame: ()=>{onDateChange( olddate => new Date(olddate.getTime() + xy.getValue()[1] * 1000))},\n                // onFrame: setLiveDate(),\n                onRest: ()=>{\n                    if (!down) {\n                        // setTimeout(()=>setActive(false),1)\n                        setActive(false)\n                        let newdate = new Date(newstart.getTime() - xy.getValue()[1] * zoomfactor)\n                        onFinalDateChange(newdate)\n                        offset.current = [0,0]\n\n                    }\n                }\n            })\n            return temp\n        }\n    })\n\n\n    useEffect(() => {\n        // if(!active) onFinalDateChange(scaledate)  \n        \n        if(!active) {\n            offset.current[1] -= (startdate.getTime() - lastStartdate.getTime())  / zoomfactor\n            // console.log(offset.current[1]+ ' /  '+ (startdate.getTime() - lastStartdate.getTime()))\n            setScaledate(startdate)\n            setlLastStartdate(startdate)\n            // onDateChange(startdate)\n        }\n    },[startdate])\n\n    useEffect(() => {\n        onDateChange(scaledate)\n    },[scaledate])\n\n\n\n    return (\n        <animated.div {...bind()} className='DateSelector' ref={selector} >\n            <div className=\"Mask\"  >\n\n                <DateSelectorScale className='scale' date={scaledate} zoomfactor={zoomfactor} immediate={active}></DateSelectorScale>\n                \n                <div className=\"TriangleContainer\" >\n                    <svg height=\"40\" width=\"20\" className=\"Triangle\">\n                        <polygon points=\"20,5 20,35 12,20\" />   \n                    </svg> \n                </div>        \n            </div>\n\n        </animated.div>\n                                  )\n}\nexport default DateSelector\n","import React, {useState, useEffect, useRef} from 'react';\nimport DateLabel from './components/datelabel'\nimport DateController from './components/datecontroller'\nimport DateSelector from './components/dateselector'\n\n\nfunction DateManager({startdate, onDateChange, onFinalDateChange, searching}) {\n\n    const [selectorStartdate, setselectorStartdate] = useState(startdate)\n    const [controllerStartdate, setcontrollerStartdate] = useState(startdate)\n    const [labeldate, setLabelDate] = useState(startdate)\n\n    const handleSelectorDateChange = (date) => {\n        // console.log('handleSelectorDateChange:' + date.toJSON())\n        setLabelDate(date)\n        onDateChange(date)\n        // setscontrollerStartdate(date)\n    }\n\n    const handleSelectorFinalDateChange = (date) => {\n        // console.log('handleSelectorFinalDateChange:' + date.toJSON())\n        setcontrollerStartdate(date)\n        // onFinalDateChange(date)\n    }\n    \n    const handleControllerDateChange = (date) => {\n        // console.log('handleControllerDateChange' + date.toJSON())\n        setselectorStartdate(date)\n    }\n\n    useEffect(() => {\n        // console.log('startdate in date manager: '+startdate.toJSON())\n        setselectorStartdate(startdate)\n    },[startdate])\n\n\n\n    return (\n        <div >\n          <DateController startdate={controllerStartdate} onDateChange={handleControllerDateChange}/>\n          <DateLabel date={labeldate} highlight='none' animated={searching}/>\n          <DateSelector startdate={selectorStartdate} onDateChange={handleSelectorDateChange} onFinalDateChange={handleSelectorFinalDateChange}/>\n        </div>\n    ) \n}\nexport default DateManager","import React, {useState, useEffect, useRef} from 'react';\nimport './App.css'\nimport Earth from '../earth'\nimport DateManager from '../datemanager'\nimport { useHotkeys } from 'react-hotkeys-hook'\n\n// import useToggle from 'react-use/lib/useToggle'\nimport Fullscreen from \"react-full-screen\"\nimport { useFullscreen } from '@straw-hat/react-fullscreen'\n\n\nfunction App() {\n    \n    let initdate = new Date()\n    const [viewdate, setViewdate] = useState(initdate)\n    const [startdate, ] = useState(initdate)\n    const [searching, ] = useState(false)\n\n    const changeDate = (newdate) => {\n        // console.log('App changeDate callback: ' + newdate.toJSON())\n        setViewdate(newdate)\n    }\n\n    useEffect(() => {\n        // console.log('Initial viewdate: '+viewdate.toJSON())\n    },[])\n      \n    useEffect(() => {\n        // console.log('startdate changed to: '+startdate.toJSON())\n    },[startdate])\n    \n    const [isFull,setIsfull] = useState(false)\n    const { isFullscreen, toggleFullscreen } = useFullscreen(window.document.body);\n    useHotkeys(\"f\",toggleFullscreen) \n\n\n    return (\n        <div className=\"App\" >\n            <Fullscreen enabled={isFull} onChange={() =>  {if(!isFullscreen) setIsfull(false)} }>\n                <div className=\"Earth\">\n                    <Earth viewdate={viewdate} id=\"globe\" starfield=\"true\" atmosphere='true' clon='0.5' clat='40' names='true'/>\n                </div>\n                <DateManager startdate={startdate}  searching={searching} onDateChange={changeDate} />\n            </Fullscreen>\n        </div>\n    )\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}